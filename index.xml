<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>MinCodes</title><link>https://mincodes.com/</link><description>MinCodes, Minimal but useful Codes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 19 Mar 2024 11:54:00 +0800</lastBuildDate><atom:link href="https://mincodes.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 中的 Pin, Unpin 和 !Unpin</title><link>https://mincodes.com/posts/pin-unpin-in-rust/</link><pubDate>Tue, 19 Mar 2024 11:54:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/pin-unpin-in-rust/</guid><description>为什么需要 Pin? 引入 Pin 的目的主要是为了支持 自引用类型 (self-referential types) 。下面我们以 Future 为例，解释一下自引用类型以及引入 Pin 的必要性。 由于异步函数中可能包含对局部变</description></item><item><title>理解 Rust 的 生命周期 (Lifetime)</title><link>https://mincodes.com/posts/understanding-lifetimes-in-rust/</link><pubDate>Wed, 06 Mar 2024 16:01:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/understanding-lifetimes-in-rust/</guid><description>Lifetime 的主要目的是防止悬空引用 (dangling references) 下面的例子中， borrow checker 会检查 r 的生命周期 'a 比其引用的数据的生命周期 'b 要长，因此会拒绝编译通过。 1 2 3 4 5 6 7 8 9 10</description></item><item><title>Rust 的 move 和 C++ 的 std::move</title><link>https://mincodes.com/posts/move-in-rust-and-cpp/</link><pubDate>Wed, 06 Mar 2024 12:19:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/move-in-rust-and-cpp/</guid><description>Rust 的 move 和 C++ 的 std::move 在表面上看有些相似之处，因为它们都涉及到数据或资源的转移。然而，它们在设计理念、实现方式以及它们在各自语言中所扮演的角色上有着</description></item><item><title>发布我的第一个 Crate: django-auth</title><link>https://mincodes.com/posts/publish-crate-django-auth/</link><pubDate>Sun, 14 Jan 2024 19:37:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/publish-crate-django-auth/</guid><description>今天发布了我的第一个 crate: django-auth, 虽然是一个非常简单的 crate, 但麻雀虽小，五脏俱全，API 文档、测试用例、doc test 等一个都不能少 😎。 先简单介绍一下这个库，然</description></item><item><title>Rust 中的特征 (Trait)</title><link>https://mincodes.com/posts/traits-in-rust/</link><pubDate>Tue, 19 Dec 2023 20:46:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/traits-in-rust/</guid><description>概述 简单来说， trait 是 Rust 中用来定义共享行为的抽象机制，和 Java 的 interface、 Swift 的 protocol 有点类似： 1 2 3 pub trait Summary { fn summarize(&amp;amp;self) -&amp;gt; String; } 单纯从提供的功能和灵活性</description></item><item><title>Rust 中的 | (竖线) 符号</title><link>https://mincodes.com/posts/rust-vertical-line/</link><pubDate>Mon, 18 Dec 2023 21:20:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/rust-vertical-line/</guid><description>Rust 中的 | 用途比较多，这里做一个简单的整理。 模式匹配中的“或”模式 (Pattern Alternatives) 在模式匹配（如 match 语句或 if let 表达式）中， | 可以用来表示多个模式的组合： 1 2</description></item><item><title>Doom Emacs 的基本用法</title><link>https://mincodes.com/posts/basic-usage-of-doom-emacs/</link><pubDate>Fri, 08 Dec 2023 16:49:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/basic-usage-of-doom-emacs/</guid><description>安装 1 2 git clone --depth 1 https://github.com/doomemacs/doomemacs ~/.config/emacs ~/.config/emacs/bin/doom install 环境变量 执行 doom env 命令，可以 dump 一份当前的 shell 环境变量，Doom 启动时会加载该环境变量。如果你的环境变量配置发生变化（例如</description></item><item><title>深度学习笔记：理论基础</title><link>https://mincodes.com/posts/deep-learning-notes-theory-foundation/</link><pubDate>Thu, 07 Dec 2023 08:34:00 +0000</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/deep-learning-notes-theory-foundation/</guid><description>深度学习和神经网络 深度学习是一种实现机器学习的技术，而神经网络是实现深度学习的基本结构。 具体来说： 神经网络: 神经网络是一种模仿人脑处理信息方</description></item><item><title>设计模式：行为型 (Behavioral)</title><link>https://mincodes.com/posts/design-patterns-behavioral/</link><pubDate>Fri, 07 Jul 2023 18:36:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-behavioral/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 责任链 (Chain of Responsibility) 意图 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系</description></item><item><title>设计模式：创建型 (Creational)</title><link>https://mincodes.com/posts/design-patterns-creational/</link><pubDate>Fri, 07 Jul 2023 18:35:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-creational/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 抽象工厂 (Abstract Factory) 意图 提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。</description></item></channel></rss>