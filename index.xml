<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Min Codes</title>
    <link>https://mincodes.com/</link>
    <description>Recent content on Min Codes</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 09 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://mincodes.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在 Emacs 中实现 VSCode 的 terminal 快捷键功能</title>
      <link>https://mincodes.com/tools/emacs-terminal/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mincodes.com/tools/emacs-terminal/</guid>
      <description>VSCode 有一个比较方便的快捷键：Ctrl-` ，可以一键拉起 terminal 。
 这里在 Emacs 中模拟一下这个功能，而且还是增强版本，可以在不同文件中拉 起不同的 terminal，拉起的 terminal 路径和当前文件的目录一致。
  ;; emacs 自带的 term 命令只支持单个 terminal，因此该功能依赖  ;; multi-term 。这里先检查有没有安装，没有的话先安装 multi-term  (unless (package-installed-p &amp;#39;multi-term)  (package-install &amp;#39;multi-term))   ;; 定义拉起 multi-term 的函数，如果当前目录已经拉起过 terminal，则直接  ;; 跳转到该 terminal。由于我的屏幕比较宽，这里会自动将 terminal 分屏到  ;; 右侧  (defun open-or-jump-to-multi-term ()  (interactive)  (if (string-prefix-p &amp;#34;*terminal&amp;lt;&amp;#34; (buffer-name)) 	(delete-window)  (progn 	(setq bufname (concat &amp;#34;*terminal&amp;lt;&amp;#34; (directory-file-name (file-name-directory (buffer-file-name))) &amp;#34;&amp;gt;&amp;#34;)) 	(if (get-buffer-process bufname) 	(switch-to-buffer-other-window bufname) 	(progn 		(split-window-right) 	(other-window 1) 	(multi-term) 	(rename-buffer bufname) 	) 	)))  )   ;; 定义快捷键，和 VSCode 一致  (global-set-key (kbd &amp;#34;C-`&amp;#34;) &amp;#39;open-or-jump-to-multi-term)   Emacs 最大的魅力，也许就是可以按照自己的喜好，随心定制各种功能吧！另外 各种文本编辑的快捷键，也是越用越顺手。</description>
    </item>
    
    <item>
      <title>Command Line Tools</title>
      <link>https://mincodes.com/tools/cmd-line-tools/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mincodes.com/tools/cmd-line-tools/</guid>
      <description>记录一些常用的命令行工具，方便随时取用。
查看 CPU 总核心数   grep -c &amp;#39;model name&amp;#39; /proc/cpuinfo    find printable strings 查找二进制文件中的字符串   例如查看 /bin 目录下的程序可能会创建哪些临时文件:
 strings /bin/* | grep tmp    查看、配置资源限制   ulimit -a  core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited file size (blocks, -f) unlimited max locked memory (kbytes, -l) unlimited max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 1 stack size (kbytes, -s) 9788 cpu time (seconds, -t) unlimited max user processes (-u) 2784 virtual memory (kbytes, -v) unlimited    测试硬盘速度   # bs 默认为 512 字节，单位支持 k/m （macOS 平台如此，Linux 上不一样）  # write  dd of=${path_on_disk} if=/dev/zero bs=1m count=1000  # read  dd if=${path_on_disk} of=/dev/null bs=1m  1000+0 records in 1000+0 records out 1048576000 bytes transferred in 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mincodes.com/coding/go-concurrency-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mincodes.com/coding/go-concurrency-patterns/</guid>
      <description>Go 并发模式总结
 Generator 发生器   Generator 指返回一个 chan 的函数。这是一种十分常见的使用 goroutine + chan 的方式，可以说是一种标准用法了。
 采用这种方式使用 chan 十分的安全，不会出现一些 chan 误用导致的错误（例 如向已经关闭的 chan 写入数据等）。
 例如下面的代码，会开一个 goroutine 递归遍历指定目录，并将目录下的所有 json 文件通过 chan 吐出去。
 func walkJsonFiles(dir string) &amp;lt;-chan string { 	out := make(chan string)  	go func() { 	defer close(out)  	err := filepath.WalkDir(dir, 	func(path string, info fs.DirEntry, err error) error {  	if err !</description>
    </item>
    
  </channel>
</rss>
