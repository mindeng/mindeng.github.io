<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>经历八年后，我是如何用 Go 写 HTTP 服务的 - MinCodes</title><meta name=Description content="MinCodes, Minimal but useful Codes"><meta property="og:title" content="经历八年后，我是如何用 Go 写 HTTP 服务的"><meta property="og:description" content="今天读到一篇不错的文章，讲如何用 Go 写 HTTP 服务的，很有同感，翻译如下。 原文链接 A Server struct 一个 Server struct 是一个代表服务的对象，持有所有依赖。 每个组件都有一个"><meta property="og:type" content="article"><meta property="og:url" content="https://mincodes.com/posts/how-i-write-http-services-in-go/"><meta property="og:image" content="https://mincodes.com/favicon.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-22T03:15:00+00:00"><meta property="article:modified_time" content="2023-02-22T08:49:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mincodes.com/favicon.svg"><meta name=twitter:title content="经历八年后，我是如何用 Go 写 HTTP 服务的"><meta name=twitter:description content="今天读到一篇不错的文章，讲如何用 Go 写 HTTP 服务的，很有同感，翻译如下。 原文链接 A Server struct 一个 Server struct 是一个代表服务的对象，持有所有依赖。 每个组件都有一个"><meta name=application-name content="MinCodes"><meta name=apple-mobile-web-app-title content="MinCodes"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://mincodes.com/posts/how-i-write-http-services-in-go/><link rel=prev href=https://mincodes.com/posts/padding-oracle-attack/><link rel=next href=https://mincodes.com/posts/use-emacs-to-analyse-log-files/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"经历八年后，我是如何用 Go 写 HTTP 服务的","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/mincodes.com\/posts\/how-i-write-http-services-in-go\/"},"genre":"posts","keywords":"golang, server","wordcount":1795,"url":"https:\/\/mincodes.com\/posts\/how-i-write-http-services-in-go\/","datePublished":"2023-02-22T03:15:00+00:00","dateModified":"2023-02-22T08:49:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"Min Deng"},"author":{"@type":"Person","name":"Min Deng"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=MinCodes><img class="lazyload logo" src=/svg/loading.min.svg data-src=/favicon.svg data-srcset="/favicon.svg, /favicon.svg 1.5x, /favicon.svg 2x" data-sizes=auto alt=/favicon.svg title=/favicon.svg><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>posts </a><a class=menu-item href=/tags/tools>tools </a><a class=menu-item href=/tags/>tags </a><a class=menu-item href=/about/>about </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=MinCodes><img class="lazyload logo" src=/svg/loading.min.svg data-src=/favicon.svg data-srcset="/favicon.svg, /favicon.svg 1.5x, /favicon.svg 2x" data-sizes=auto alt=/favicon.svg title=/favicon.svg><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>posts</a><a class=menu-item href=/tags/tools title>tools</a><a class=menu-item href=/tags/ title>tags</a><a class=menu-item href=/about/ title>about</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">经历八年后，我是如何用 Go 写 HTTP 服务的</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Min Deng</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-02-22>2023-02-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 1795 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#a-server-struct>A Server struct</a></li><li><a href=#routesgo>routes.go</a></li><li><a href=#handlers-挂着hang-off-server-对象>Handlers 挂着（hang off） server 对象</a></li><li><a href=#返回-handler>返回 handler</a></li><li><a href=#通过参数传递-handler-的特定依赖>通过参数传递 handler 的特定依赖</a></li><li><a href=#使用-handlerfunc-而非-handler>使用 HandlerFunc 而非 Handler</a></li><li><a href=#中间件就是普通的-go-函数>中间件就是普通的 Go 函数</a></li><li><a href=#就地定义请求和响应类型>就地定义请求和响应类型</a></li><li><a href=#类型定义可以帮助人们构造测试用例以及理解代码>类型定义可以帮助人们构造测试用例，以及理解代码</a></li><li><a href=#利用-synconce-设置依赖>利用 sync.Once 设置依赖</a></li><li><a href=#服务可测性>服务可测性</a></li></ul></nav></div></div><div class=content id=content><p>今天读到一篇不错的文章，讲如何用 Go 写 HTTP 服务的，很有同感，翻译如下。</p><p><a href=https://pace.dev/blog/2018/05/09/how-I-write-http-services-after-eight-years.html target=_blank rel="noopener noreffer">原文链接</a></p><h2 id=a-server-struct>A Server struct</h2><p>一个 Server struct 是一个代表服务的对象，持有所有依赖。</p><p>每个组件都有一个唯一的 server struct，最后看起来通常类似这个样子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>server</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>db</span> <span class=o>*</span><span class=nx>someDatabase</span>
</span></span><span class=line><span class=cl>	<span class=nx>router</span> <span class=o>*</span><span class=nx>someRouter</span>
</span></span><span class=line><span class=cl>	<span class=nx>email</span> <span class=nx>EmailSender</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>该结构的字段主要是各种需要共享的依赖</li></ul><h2 id=routesgo>routes.go</h2><p>每个组件都有一个 <code>routers.go</code> 文件，包含所有的路由：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>app</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>routes</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/api/&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nf>handleAPI</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/about&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nf>handleAbout</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nf>handleIndex</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>由于大部分代码维护工作都是从一个 URL 和一个错误报告开始的，所以只需要看一眼 <code>routes.go</code> 文件，即可知道应该去那里查找问题。</p><h2 id=handlers-挂着hang-off-server-对象>Handlers 挂着（hang off） server 对象</h2><p>HTTP handlers 挂着 server 对象：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>handleSomething</span><span class=p>()</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Handlers 可以通过 server 对象访问依赖。</p><h2 id=返回-handler>返回 handler</h2><p>Handler 函数不直接处理请求，而是返回一个函数处理之。</p><p>这样我们就有一个闭包环境，在这里我们的 handler 可以这样操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>handleSomething</span><span class=p>()</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>thing</span> <span class=o>:=</span> <span class=nf>prepareThing</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// use the thing
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>prepareThing()</code> 方法只会被调用一次，因此你可以用来执行一次性的 handler 初始化动作，然后在 handler 中使用初始化的结果（ <code>thing</code> ）。</p><p>在访问共享数据时，确保只执行读操作，否则需要加锁或者类似的保护措施。</p><h2 id=通过参数传递-handler-的特定依赖>通过参数传递 handler 的特定依赖</h2><p>如果一个 handler 需要一个特殊依赖，可以通过参数来传递。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>handleGreeting</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>format</span><span class=p>,</span> <span class=s>&#34;World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=使用-handlerfunc-而非-handler>使用 HandlerFunc 而非 Handler</h2><p>我几乎在所有情况下都使用 <code>http.HandlerFunc</code> ，而非 <code>http.Handler</code> 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>handleSomething</span><span class=p>()</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>两者基本上是可互换的，只需要选一个可读性更强的就好。对我而言， <code>http.HandlerFunc</code> 会好点。</p><h2 id=中间件就是普通的-go-函数>中间件就是普通的 Go 函数</h2><p>中间件函数接受一个 <code>http.HandlerFunc</code> 参数，并返回一个新的 <code>http.HandlerFunc</code> ，新的这个 handler 可以在调用传入的 handler 之前或之后，执行任意代码，也可以选择完全不执行传入的 handler。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>adminOnly</span><span class=p>(</span><span class=nx>h</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nf>currentUser</span><span class=p>(</span><span class=nx>r</span><span class=p>).</span><span class=nx>IsAdmin</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>http</span><span class=p>.</span><span class=nf>NotFound</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>h</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上述例子中，如果 <code>IsAdmin</code> 为 false，则返回 404 并且终止处理。注意这种情况下，传入的 h handler 并未被调用。</p><p>如果 <code>IsAdmin</code> 为 true，则正常走传入的 h handler 逻辑。</p><p>中间件也可以列在 <code>routes.go</code> 中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>app</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>routes</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/api/&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>handleAPI</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/about&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nf>handleAbout</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nf>handleIndex</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/admin&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nf>adminOnly</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nf>handleAdminIndex</span><span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=就地定义请求和响应类型>就地定义请求和响应类型</h2><p>如果一个端点（endpoint）有自己的请求、响应类型，通常这些类型只对改 handler 有用。</p><p>如果确实如此，则可以直接在函数内部定义这些类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>handleSomething</span><span class=p>()</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>type</span> <span class=nx>request</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>type</span> <span class=nx>response</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Greeting</span> <span class=kt>string</span> <span class=s>`json:&#34;greeting&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这样不会污染你的包命名空间，允许你在不同的 handler 中使用相同的名字，而非为每个 handler 想一个不同的名字。</p><p>在测试代码中，也可以直接拷贝这些类型定义到测试函数中。</p><h2 id=类型定义可以帮助人们构造测试用例以及理解代码>类型定义可以帮助人们构造测试用例，以及理解代码</h2><p>如果你的请求、响应类型隐藏在 handler 内部，你可以在测试代码中直接定义新类型。</p><p>这是一个表达你的意图，方便后人理解你的代码的机会。</p><p>例如，假设有一个 <code>Person</code> 类型，在很多端点（endpoint）中被复用。其中有一个 <code>/greet</code> 端点，我们大概率只关心 <code>Person.name</code> 这个字段，因此我们可以在测试代码中表达这一点：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestGreet</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>is</span> <span class=o>:=</span> <span class=nx>is</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Name</span> <span class=kt>string</span> <span class=s>`json:&#34;name&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=p>}{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;Mat Ryer&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>buf</span> <span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>buf</span><span class=p>).</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>is</span><span class=p>.</span><span class=nf>NoErr</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=c1>// json.NewEncoder
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>req</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewRequest</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>MethodPost</span><span class=p>,</span> <span class=s>&#34;/greet&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>is</span><span class=p>.</span><span class=nf>NoErr</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ... more test code here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>仅从功能测试角度来讲，这么做是 OK 的，被测代码的用法也表达的很清楚。但是从鲁棒性测试的角度，也许需要考虑到传递整个数据结构进去，会不会产生什么问题？</p></blockquote><h2 id=利用-synconce-设置依赖>利用 sync.Once 设置依赖</h2><p>在准备 handler 的时候，如果需要执行一些成本比较高的初始化操作，可以考虑将该操作延迟到该 handler 第一次被调用的时候。</p><p>这可以改善应用的启动时间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>server</span><span class=p>)</span> <span class=nf>handleTemplate</span><span class=p>(</span><span class=nx>files</span> <span class=kt>string</span><span class=o>...</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>init</span>    <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>		<span class=nx>tpl</span>     <span class=o>*</span><span class=nx>template</span><span class=p>.</span><span class=nx>Template</span>
</span></span><span class=line><span class=cl>		<span class=nx>tplerr</span>  <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>init</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>tpl</span><span class=p>,</span> <span class=nx>tplerr</span> <span class=p>=</span> <span class=nx>template</span><span class=p>.</span><span class=nf>ParseFiles</span><span class=p>(</span><span class=nx>files</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>tplerr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>http</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>tplerr</span><span class=p>.</span><span class=nf>Error</span><span class=p>(),</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusInternalServerError</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// use tpl
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>sync.Once</code> 确保该代码只会被执行一次，而且其他调用（其他人发起同一个请求时）会一直阻塞直到执行结束。</p><ul><li>错误检查放在 init 函数外面，因此如果有错误发生，我们可以暴露出该错误，同时保留错误日志</li><li>如果该 handler 未被调用，则该高成本操作永远不会被执行。有些情况下这样做有很大收益，取决于你的代码是如何部署的</li></ul><blockquote><p>这种方式实际上是将初始化时间从启动阶段转移到了运行时。如果使用 Google App Engine 则很有用，其他场景则需要单独考虑。</p></blockquote><h2 id=服务可测性>服务可测性</h2><p>上述的 server 类型是充分可测的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestHandleAbout</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>is</span> <span class=o>:=</span> <span class=nx>is</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>srv</span> <span class=o>:=</span> <span class=nx>server</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>db</span><span class=p>:</span>     <span class=nx>mockDatabase</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>email</span><span class=p>:</span>  <span class=nx>mockEmailSender</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>srv</span><span class=p>.</span><span class=nf>routes</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>req</span> <span class=o>:=</span> <span class=nx>httptest</span><span class=p>.</span><span class=nf>NewRequest</span><span class=p>(</span><span class=s>&#34;GET&#34;</span><span class=p>,</span> <span class=s>&#34;/about&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span> <span class=o>:=</span> <span class=nx>httptest</span><span class=p>.</span><span class=nf>NewRecorder</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>srv</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>is</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>w</span><span class=p>.</span><span class=nx>StatusCode</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>在每个测试中创建一个 server 实例 —— 如果耗时操作是懒加载的，那么这么做不会耗费太多时间，即使对于大组件来说也适用</li><li>通过调用 server 的 <code>ServeHTTP</code> 方法，包括路由、中间件等整个栈都可以被测到。当然，如果你不希望测试整个栈，也可以直接调用 handler 方法</li><li>使用 <code>httptest.NewRequest</code> 和 <code>httptest.NewRecorder</code> 来记录 handlers 都做了什么</li><li>代码中使用了 <code>is</code> 测试框架，Testify 的一个迷你替代版本：<a href=https://github.com/matryer/is target=_blank rel="noopener noreffer">is</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-02-22</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/golang/>golang</a>,&nbsp;<a href=/tags/server/>server</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/padding-oracle-attack/ class=prev rel=prev title="Padding Oracle Attack"><i class="fas fa-angle-left fa-fw"></i>Padding Oracle Attack</a>
<a href=/posts/use-emacs-to-analyse-log-files/ class=next rel=next title="用 Emacs 分析日志文件">用 Emacs 分析日志文件<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Min Deng</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},data:{"id-1":"MinCodes","id-2":"MinCodes"},typeit:{cursorChar:null,cursorSpeed:null,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:null,speed:null}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EPY7LC720X",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-EPY7LC720X" async></script></body></html>