<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>软件设计原则、设计模式总结 - MinCodes</title><meta name=Description content="MinCodes, Minimal but useful Codes"><meta property="og:title" content="软件设计原则、设计模式总结"><meta property="og:description" content="前言 本文是笔者对软件设计原则、设计模式的一个梳理，很多内容参考自《设计模式：可复用面向对象软件的基础》一书（尤其是设计模式部分）。其中也包含"><meta property="og:type" content="article"><meta property="og:url" content="https://mincodes.com/posts/design-patterns/"><meta property="og:image" content="https://mincodes.com/favicon.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-21T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-01T23:22:35+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mincodes.com/favicon.svg"><meta name=twitter:title content="软件设计原则、设计模式总结"><meta name=twitter:description content="前言 本文是笔者对软件设计原则、设计模式的一个梳理，很多内容参考自《设计模式：可复用面向对象软件的基础》一书（尤其是设计模式部分）。其中也包含"><meta name=application-name content="MinCodes"><meta name=apple-mobile-web-app-title content="MinCodes"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://mincodes.com/posts/design-patterns/><link rel=prev href=https://mincodes.com/posts/android-binder/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"软件设计原则、设计模式总结","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/mincodes.com\/posts\/design-patterns\/"},"genre":"posts","keywords":"design-pattern, architecture, android","wordcount":10982,"url":"https:\/\/mincodes.com\/posts\/design-patterns\/","datePublished":"2023-04-21T00:00:00+00:00","dateModified":"2023-07-01T23:22:35+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Min Deng"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=MinCodes><img class="lazyload logo" src=/svg/loading.min.svg data-src=/favicon.svg data-srcset="/favicon.svg, /favicon.svg 1.5x, /favicon.svg 2x" data-sizes=auto alt=/favicon.svg title=/favicon.svg><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>posts </a><a class=menu-item href=/tags/tools>tools </a><a class=menu-item href=/tags/>tags </a><a class=menu-item href=/about/>about </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=MinCodes><img class="lazyload logo" src=/svg/loading.min.svg data-src=/favicon.svg data-srcset="/favicon.svg, /favicon.svg 1.5x, /favicon.svg 2x" data-sizes=auto alt=/favicon.svg title=/favicon.svg><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>posts</a><a class=menu-item href=/tags/tools title>tools</a><a class=menu-item href=/tags/ title>tags</a><a class=menu-item href=/about/ title>about</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">软件设计原则、设计模式总结</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Min Deng</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-04-21>2023-04-21</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 10982 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 22 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#概念和术语>概念和术语</a><ul><li><a href=#对象间关系>对象间关系</a></li></ul></li><li><a href=#设计原则>设计原则</a><ul><li><a href=#solid-原则>SOLID 原则</a><ul><li><a href=#single-responsibility-principle-单一职责原则>Single-responsibility Principle 单一职责原则</a></li><li><a href=#open-closed-principle-开闭原则>Open-closed Principle 开闭原则</a></li><li><a href=#liskov-substitution-principle-里氏替换原则>Liskov Substitution Principle 里氏替换原则</a></li><li><a href=#interface-segregation-principle-接口隔离原则>Interface Segregation Principle 接口隔离原则</a></li><li><a href=#dependency-inversion-principle-依赖倒置原则>Dependency Inversion Principle 依赖倒置原则</a></li></ul></li><li><a href=#separation-of-concerns-分离关注点>Separation of Concerns 分离关注点</a></li><li><a href=#law-of-demeter-最少知识原则>Law of Demeter 最少知识原则</a></li><li><a href=#composite-reuse-principle-组合复用原则>Composite Reuse Principle 组合复用原则</a></li></ul></li><li><a href=#设计模式>设计模式</a><ul><li><a href=#模式的分类>模式的分类</a></li><li><a href=#常见的设计问题及相关模式应用>常见的设计问题及相关模式应用</a></li><li><a href=#设计模式所支持的设计的可变方面>设计模式所支持的设计的可变方面</a></li><li><a href=#creational-创建型模式>Creational 创建型模式</a><ul><li><a href=#abstract-factory-抽象工厂>Abstract Factory 抽象工厂</a></li><li><a href=#factory-method-工厂方法>Factory Method 工厂方法</a></li><li><a href=#builder-生成器>Builder 生成器</a></li><li><a href=#prototype-原型>Prototype 原型</a></li></ul></li><li><a href=#structural-结构型模式>Structural 结构型模式</a><ul><li><a href=#adapter-适配器>Adapter 适配器</a></li><li><a href=#bridge-桥接>Bridge 桥接</a></li><li><a href=#composite-组合>Composite 组合</a></li><li><a href=#decorator-装饰器>Decorator 装饰器</a></li><li><a href=#facade-外观>Facade 外观</a></li><li><a href=#flyweight-享元>Flyweight 享元</a></li><li><a href=#proxy-代理>Proxy 代理</a></li></ul></li><li><a href=#behavioral-行为型模式>Behavioral 行为型模式</a><ul><li><a href=#chain-of-responsibility-责任链>Chain of Responsibility 责任链</a></li><li><a href=#command-命令>Command 命令</a></li><li><a href=#iterator-迭代器>Iterator 迭代器</a></li><li><a href=#mediator-中介者>Mediator 中介者</a></li><li><a href=#memento-备忘录>Memento 备忘录</a></li><li><a href=#observer-观察者>Observer 观察者</a></li><li><a href=#state-状态>State 状态</a></li><li><a href=#strategy-策略>Strategy 策略</a></li><li><a href=#template-method-模板方法>Template Method 模板方法</a></li><li><a href=#visitor-访问者>Visitor 访问者</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=前言>前言</h2><p>本文是笔者对软件设计原则、设计模式的一个梳理，很多内容参考自《设计模式：可复用面向对象软件的基础》一书（尤其是<a href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f rel>设计模式</a>部分）。其中也包含了笔者个人的一些思考和总结。</p><h2 id=概念和术语>概念和术语</h2><p>本章整理了一些容易混淆的概念和术语。</p><h3 id=对象间关系>对象间关系</h3><p>先用一张 UML 图来直观展示一下：</p><figure><img src=/ox-hugo/object-relationships.png></figure><p>简单解释一下：</p><dl><dt>Inheritance</dt><dd>继承，这个很好理解，就是父类和子类的关系。</dd><dt>Composition</dt><dd>合成，这个是除了继承以外，两个对象之间所能有的最强的关系。合成意味着：<ul><li><code>Eye</code> is a part of <code>Dog</code>, 即 <code>Eye</code> 是 <code>Dog</code> 不可分割的一部分。</li><li><code>Eye</code> 的生命周期完且由 <code>Dog</code> 控制， <code>Dog</code> 消失则 <code>Eye</code> 也不复存在。</li></ul><p>从实现上来说，一般 <code>Eye</code> 对象作为 <code>Dog</code> 的一个成员变量，且由 <code>Dog</code> 负责 <code>Eye</code> 的创建及其完整的生命周期管理。</p></dd><dt>Aggregation</dt><dd>聚合，关系强度次于 <em>Composition</em> 。其含义如下：<ul><li>班级由全班学生组成，但学生不是班级不可分割的一部分（因为学生可以转学，但是班级会一直存在）。</li><li>两者的生命周期也不需要完且一致。一方面，学生可以辍学或者转学，但班级不受影响；另一方面，班级也可以解散或重组（比如合并到其他班），但学生仍然存在。</li></ul><p>从实现上来说， <code>Student</code> 对象由 <code>Class</code> 对象所持有，且一般是通过 <code>Class</code> 的一个集合类成员变量所持有。</p></dd><dt>Association</dt><dd>关联，关系强度再次之。其仅仅意味着 <em>Has-A</em> 的关系。单从对象持有的角度看，和 <em>Aggregation</em> 的差别不大，我个人觉得主要的区别可能有如下几点：<ul><li><em>Aggregation</em> 会更强调“集体－个体”的关系一些，一般来说隐含了“一对多”的意思。</li><li><em>Association</em> 是一种更加通用的“对象间持有关系”的描述，范围会比 Aggregation 更广。事实上， <em>Aggregation</em> 可以看作是 <em>Association</em> 的一种特例。</li></ul><p>从实现上来说， <code>VideoEditor</code> 会持有一个 <code>MediaCodec</code>, 一般是通过一个成员变量来持有。</p></dd><dt>Dependency</dt><dd>依赖，这个应该是强度最弱的一种关系了，仅表示两者之间存在依赖关系，但并不限定两者之间是如何依赖的。例如，最弱的一种依赖可能是在 A 对象所属的类的某个方法里面使用到了 B 类。正如图中的示例，视频编辑器在加载某张图片素材的时候，可能在 <code>loadImage()</code> 方法中使用了 <code>ImageDecoder</code>, 但并不会在成员变量中持有该对象的引用。</dd></dl><p>下面这张图展示了 <em>Association</em>, <em>Composition</em>, <em>Aggregation</em> 三者之间的关系：</p><figure><img src=/ox-hugo/relationships-venn.png></figure><h2 id=设计原则>设计原则</h2><h3 id=solid-原则>SOLID 原则</h3><p><strong>SOLID</strong> 指面向对象设计的五个基本原则：</p><ul><li><strong>S</strong>​ingle-responsibility Principle 单一职责原则</li><li><strong>O</strong>​pen-closed Principle 开闭原则</li><li><strong>L</strong>​iskov Substitution Principle 里氏替换原则</li><li><strong>I</strong>​nterface Segregation Principle 接口隔离原则</li><li><strong>D</strong>​ependency Inversion Principle 依赖倒置原则</li></ul><p>下面对这五个基本原则逐一进行介绍。</p><h4 id=single-responsibility-principle-单一职责原则>Single-responsibility Principle 单一职责原则</h4><blockquote><p><em>一个类应该只对一件事情负责。</em></p></blockquote><p>换句话说，就是​<strong>一个类应该只有一个引起变化的原因</strong>​。</p><p>我们知道，对现有代码进行修改是很容易引起问题的。如果一个类具有两个或更多的引起修改的原因，那么将来这个类变化的几率将会大大上升。而且当它真正被修改时，你设计中的两个或多个方面都会受到影响（取决于该类的职责数量），不可控因素会进一步提高。同时，职责过多也会增加后续维护人员的理解成本。</p><p>举个例子，比如设计模式中的<a href=#iterator-%e8%bf%ad%e4%bb%a3%e5%99%a8 rel>迭代器模式</a>，就帮助我们把对集合的遍历操作这项职责给剥离出来，使得集合内部只需关心集合自身功能的实现，而无需操心如何遍历集合元素这项功能。相反，如果我们直接在集合内部实现迭代功能，那我们就给了这个类两个变化的原因：</p><ol><li>如果集合本身的功能（例如元素的存储结构或操作）发生改变，这个类会被修改；</li><li>如果遍历的方式发生改变，这个类也会被修改。</li></ol><p>因此，这个类将来被修改的机率大幅上升，增加了代码的不稳定因素。另外，由于这两项功能放在一起实现，彼此之间很可能会发生互相耦合，修改其中一项可能会导致另一项也需要修改，从而增加修改的复杂度和出错的概率。</p><p>设计模式中还有很多模式都遵守了单一职责原则，例如<a href=#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82 rel>抽象工厂</a>将产品对象的构造这一职责独立出来，客户的可以直接通过工厂接口拿到产品接口，而无需关心具体产品是如何实现以及如何实例化的；再比如<a href=#bridge-%e6%a1%a5%e6%8e%a5 rel>桥接模式</a>，将抽象的设计部分和它所倚赖的实现部分分离，使二者可以独立发生变化，等等。</p><p>另一个很有用的概念是分离关注点，这个概念和单一职责原则有点类似，但是角度不太一样。具体我们在<a href=#separation-of-concerns-%e5%88%86%e7%a6%bb%e5%85%b3%e6%b3%a8%e7%82%b9 rel>分离关注点</a>章节中进一步讨论。</p><h4 id=open-closed-principle-开闭原则>Open-closed Principle 开闭原则</h4><blockquote><p>系统应该对扩展开放，对修改关闭。</p></blockquote><p>这里的关键词是“修改”。软件之所以要做设计，很大程度上就是因为需要应对未来的修改，换句话说，需要应对未来的变化。这种变化包括新增需求以及对现有需求的修改。</p><p>为了适应这种变化，并且在适应变化的同时，保持系统的健壮性，我们必须考虑系统在它的生命周期内会发生怎样的变化。一个不考虑变化的设计，在将来很可能需要大规模重构，这意味着重新设计、开发和测试，以及依赖方的修改，这种代价是十分巨大的。</p><p>坚持开闭原则不但能够帮助我们更好的适应变化，而且还有助于我们建立起稳定且高质量的『货架产品』。试想一下，如果我们的组件开发出来之后，不需要因为客户的需求而时常发生修改（只有日常维护、bugfix），在客户有新的需求时，都是通过扩展现有组件（继承或组合）、新增组件的方式来满足客户诉求，那么随着时间的推移，线上的场景验证、线下的测试覆盖会越来越多，现存组件的质量和稳定性会越来越高（因为 bugfix 在持续进行，且没有引入新的修改点）。这样持续发展下去，我们就可以建立一个高质量的组件库，即我们说的『货架产品』。</p><p>当然，要做到这一点并不容易。这里整理一个大致的思路供参考：</p><ul><li><p><strong>找出潜在的变化点</strong>​。在设计之初，从需求角度出发，考察模块中哪些部分将来可能会发生变化，把这些潜在的变化点找出来。</p></li><li><p><strong>对变化进行封装和隔离</strong>​。变化点找出来之后，思考一下，将来这些变化真正来临的时候，我们会如何支持？</p><p>是否可以在不修改现有模块代码的前提下（可以新增代码，例如新写一个类），通过某种机制优雅的支持这种变化？例如在运行时替换某个对象，或者新增一个子类来自定义基类的部分行为？想清楚这点之后，我们就实现了对变化进行封装和隔离。</p></li></ul><p>上面是一个思路，具体应该如何做呢？ 设计模式为我们指明了道路。</p><p>​<strong>设计模式可以确保系统能够以某种特定的方式发生变化</strong>​，从而帮助你在面临这种变化时避免重新设计。每一个设计模式都允许系统结构的某个方面的变化独立于其他方面，这样产生的系统可以更好地适应这种变化，从而更加健壮。进一步的阐述见<a href=#%e5%b8%b8%e8%a7%81%e7%9a%84%e8%ae%be%e8%ae%a1%e9%97%ae%e9%a2%98%e5%8f%8a%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f%e5%ba%94%e7%94%a8 rel>常见的设计问题及相关模式应用</a>、<a href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e6%89%80%e6%94%af%e6%8c%81%e7%9a%84%e8%ae%be%e8%ae%a1%e7%9a%84%e5%8f%af%e5%8f%98%e6%96%b9%e9%9d%a2 rel>设计模式所支持的设计的可变方面</a>两节。</p><p>一款不能适应变化的软件是没有生命力的，而且注定会以失败告终，让我们积极拥抱变化😏。</p><h4 id=liskov-substitution-principle-里氏替换原则>Liskov Substitution Principle 里氏替换原则</h4><blockquote><p>基类对象应该可以被子类对象无缝替换。</p></blockquote><p>除了明显的字面意思，这里从『基类设计者』和『子类实现者』两个角度，补充一点个人的理解。</p><dl><dt>基类设计角度</dt><dd>基类在设计时，应该慎重定义可重写（ <code>overwrite</code> ）方法。每个 <code>overwrite</code> 方法都应该有明确的设计意图。<p>基类定义的每一个 <code>overwrite</code> 方法，都应该是有意为之，不能随便定义。例如，模板方法中开放出来的 <code>overwrite</code> 方法，是有意让子类重写整个算法流程中的某些步骤。</p><p>慎重定义 <code>overwrite</code> 方法，可以有效防止 <code>overwrite</code> 方法语义混乱、用途不明确以及子类错误重写的问题，也可以降低子类实现者的心智负担。</p></dd><dt>子类实现角度</dt><dd>子类在实现时，应该理解基类的工作机制，遵守基类的设计意图，严格按照继承协议来重写 <code>overwrite</code> 方法，并确保遵循里氏替换原则。</dd></dl><h4 id=interface-segregation-principle-接口隔离原则>Interface Segregation Principle 接口隔离原则</h4><blockquote><p>提供多个分离的接口，而非提供一个宽泛用途的接口。</p></blockquote><p>提供隔离的接口至少有两方面的好处：</p><ul><li>从使用者的角度讲，互相隔离接口的接口相较一个大而全的接口，使用起来更加简单、高效，可以有效减少误用，同时降低使用者的心智负担；</li><li>从设计者的角度讲，提供相互隔离的接口除了有利于保持组件接口的简洁清晰，同时还会迫使设计者思考清楚系统的核心（原子）接口是什么，从而在机制层面对系统的设计思考的更加透彻一些，而不是 case by case 的提供业务所需要的各项功能。</li></ul><p>实际上，由于分离接口也意味着分离职责，因此该原则也暗合单一职责原则。</p><h4 id=dependency-inversion-principle-依赖倒置原则>Dependency Inversion Principle 依赖倒置原则</h4><blockquote><p>依赖抽象，不要依赖具体实现。</p></blockquote><ul><li>高层组件不应该依赖低层组件</li><li>不管高层组件或低层组件，两者都应该依赖抽象，而非具体实现</li></ul><p>考虑这样一个例子，假设我们有一款视频编辑器，其中有一项贴纸功能，允许用户选择不同类型的贴纸，比如有静态贴纸、动态贴纸等。</p><p>多种贴纸类型意味着有多个贴纸的实现类，例如：</p><dl><dt>StaticSticker</dt><dd>支持单张图片的静态贴纸</dd><dt>AnimatedSticker</dt><dd>支持图片序列帧的动态贴纸</dd></dl><p>贴纸类型不同，使用方式也有所不同。例如，静态贴纸只需一张图片，以及贴纸的绘制区域、起始时间、结束时间；而动态贴纸需要一个序列帧，而且该序列帧的时间间隔可能是固定的，也可能是不固定的。如果在编辑器的主程序中直接使用这两个未经抽象的贴纸实现类，结果可能是灾难性的：</p><ul><li>由于主程序需要关注具体的贴纸实现类，导致我们在主程序中引入了一个新的引起变化的原因（参考<a href=#single-responsibility-principle-%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99 rel>单一职责原则</a>）,后续需要扩展新的贴纸，或者某个贴纸实现需要调整时，都可能会引起主程序的修改；</li><li>由于不同贴纸的使用逻辑（接口）可能不同，主程序中可能会充斥着各种 <code>if else</code> 或者
<code>switch case</code> 的分支语句，在扩展新贴纸，或者调整贴纸工作流程的时候，会引发
<strong>Shotgun Surgery 霰弹式修改</strong> (参考《重构》3.6 章)。</li></ul><p>如何解决该问题？答案就是 <strong>依赖倒置</strong> 。我们应该依赖 Sticker 的抽象接口，而不能直接依赖不同贴纸的具体实现类。具体如何做到呢？下面简单提供一个思路。</p><ul><li><p>对贴纸进行抽象设计，得到贴纸接口 <code>Sticker</code>
仔细分析贴纸的需求，我们发现大致可以定义出如下几个接口：</p><ul><li><code>getStartTime()</code> - 获取起始时间</li><li><code>getEndTime()</code> - 获取结束时间</li><li><code>getRect()</code> - 获取绘制区域</li><li><code>getImageAtTime()</code> - 获取任意时刻的图片</li></ul><p>有了上述几个接口，主程序就能够实现基本的贴纸绘制流程了。因此，主程序就可以脱离对贴纸具体实现的依赖，转变成依赖抽象接口 Sticker 了。</p></li><li><p>有了 <code>Sticker</code> 之后，我们会发现其实还不太够。因为我们仍然需要在主程序中构造出具体的某个贴纸，不同贴纸的构造逻辑可能是不同的，而且后续可能会发生变化，因此，这仍然会导致对具体实现的依赖。如何摆脱这种依赖？我们进一步将对象的构造过程进行抽象，抽象出一个 <code>StickerFactory</code> 接口：</p><ul><li><code>createSticker(): Sticker</code> 创建某种类型的贴纸，并返回 <code>Sticker</code> 接口</li></ul></li></ul><p>有了上述两个接口，主程序算是彻底摆脱了对贴纸具体实现类的依赖了，且双方都可以独立对实现进行调整，而不会互相产生影响。</p><p>也许你可能会问，那 <code>StickerFactory</code> 对象又如何构造呢？这个对象其实可以委托给贴纸选择程序来构造，也就是说，在用户选中某一款贴纸时，该贴纸的类型其实已经确定了，在这里可以恰当的构造出具体所需要的 <code>StickerFactory</code> （ <code>StaticStickerFactory</code> 或者
<code>AnimatedStickerFactory</code> 实例）。</p><p>这个例子讲完了，看起来是不是很眼熟？没错，这个就是抽象工厂模式的一个简化版本。下面是这个例子的类图，方便理解：</p><figure><img src=/ox-hugo/sticker-class-diagram.png></figure><h3 id=separation-of-concerns-分离关注点>Separation of Concerns 分离关注点</h3><blockquote><p>分离关注点是指将软件划分为若干个彼此独立的单元，每个单元处理一个分离的关注点，不同单元之间保持隔离，仅通过定义良好的接口进行通信。</p></blockquote><p><strong>Separation of Concerns</strong> , 简称 <strong>SoC</strong> 。相比<a href=#single-responsibility-principle-%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99 rel>单一职责原则</a>来说，我觉得分离关注点的概念会更通用化一些，更多强调了如何降低开发者的心智负担。例如，我在开发 A 模块的时候，可以不用操心其他 B/C/D 模块的任何细节，可以专注投入到 A 模块的开发工作上，这样效率最高，而且不容易出错。</p><p>另外， <strong>SoC</strong> 除了表达单一职责的内涵，还隐含了单个模块应该足够内聚，模块之间应该尽量解耦，只能通过定义明确的接口来通信等意思，否则是做不到分离关注点的。</p><p>这个概念可以涵盖到多个不同的层面，可以小到一个函数、一个类的划分，大到一个模块、一个子系统，也可以是软件的分层设计。例如 TCP/IP 协议模型，就是一个典型的符合 SoC
原则的设计。</p><h3 id=law-of-demeter-最少知识原则>Law of Demeter 最少知识原则</h3><blockquote><p>也叫迪米特法则，是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块之间相对独立。这样，当修改某一个模块时，就会尽量少的影响到其他模块，扩展也会相对更加容易。</p></blockquote><p>这其实是对软件实体之间的通信进行约束，其本质是要求我们在进行软件设计时，要做到实体内部的​<strong>高内聚</strong>, 以及实体之间的​<strong>低耦合</strong>​。</p><p>例如在 Android 开发过程中，如果是采用 <em>MvvM</em> 架构，比较好的实践是尽可能的把你的
<em>Model</em> 层逻辑，甚至是 <em>ViewModel</em> 层逻辑做到平台无关，即 <strong>保持对平台的最少知识（依赖)</strong>,这样做至少有如下好处：</p><ul><li>可以确保你尊循了 <em>MvvM</em> 架构规范， <em>Model</em> & <em>ViewModel</em> 层不会对 <em>View</em> 层有直接的依赖。 <em>ViewModel</em> 和 <em>View</em> 之间仅保持数据发布/订阅的关系，不对 <em>View</em> 产生直接依赖。在 Android 平台， 避免 <em>ViewModel</em> 对 <em>View</em> 层的依赖十分必要，这可以避免很多生命周期方面的问题（因为 <em>ViewModel</em> 比 <em>View</em> 层的对象往往具有更长的生命周期）。</li><li>你的 <em>Model</em> & <em>ViewModel</em> 和平台无关，具备足够的灵活性。例如在 Android SDK 发生变更或者手机厂商行为不一致时，可以更容易的在上层做适配，而无需修改核心业务逻辑。</li><li>整个系统的可测性将大幅提升， <em>Model</em> & <em>ViewModel</em> 都可以进行独立的单元测试，而且这种​<strong>单元测试是可以脱离 Android 设备或者 Android 模拟器独立进行</strong>​的，即可以直接在 PC 上跑，测试、调试效率也得到了大幅提升。</li></ul><p>关于 <em>ViewModel</em> 的单元测试可以参考官方的<a href="https://developer.android.com/codelabs/basic-android-kotlin-compose-test-viewmodel?hl=zh-cn#0" target=_blank rel="noopener noreffer">这篇 Codelab 示例</a>。</p><h3 id=composite-reuse-principle-组合复用原则>Composite Reuse Principle 组合复用原则</h3><blockquote><p>多用组合(HAS-A)，少用继承(IS-A)。</p></blockquote><p>采用组合的方式来实现新功能，有如下好处：</p><dl><dt>类之间的耦合更低</dt><dd>由于继承属于 <strong>白箱复用</strong> ,父类的内部细节对子类基本是可见的，这种复用方式在某种程度上破坏了父类的封装性，一旦父类的实现发生变化，子类很有可能面临修改。而组合属于 <strong>黑箱复用</strong> ,在复用时仅依赖其外部稳定接口，内部实现细节对客户来说是不可见的。因此，组合的方式明显具有更低的耦合性。</dd><dt>更加简单，不容易出错</dt><dd>继承需要对父类的工作机制有一定的了解，一旦对 <code>overwrite</code>
方法（或属性）的设计意图产生错误理解，很容易导致难以预料的后果（参考<a href=#liskov-substitution-principle-%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99 rel>里氏替换原则</a>）。组合则相对简单一些，只需理解 <code>public</code> 接口即可。</dd><dt>不会产生庞大而不可控的继承体系</dt><dd>如果滥用继承，很容易导致一个庞大的继承体系，到最后没有人能真正搞懂整个系统是怎么工作的，改代码变得如履薄冰。而采用组合则不会有这个问题。</dd></dl><p>另外，组合相比继承需要的知识更少，这点和<a href=#law-of-demeter-%e6%9c%80%e5%b0%91%e7%9f%a5%e8%af%86%e5%8e%9f%e5%88%99 rel>最少小知识原则</a>也是相符的。</p><h2 id=设计模式>设计模式</h2><h3 id=模式的分类>模式的分类</h3><p>根据模式的目的和范围，可以将设计模式大致划分为如下类别：</p><table border=1><tr><td rowspan=2 align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td rowspan=2 align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td colspan=3 align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td align=left valign=top>&nbsp;创建型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;&nbsp;结构型&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;行为型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td rowspan=2 align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;范围&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;类&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;Factory&nbsp;Method&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;&nbsp;Adapter&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;Interpreter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Template&nbsp;Method&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;对象&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Abstract&nbsp;Factory&nbsp;<br>&nbsp;Builder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Prototype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Singleton&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Adapter&nbsp;&nbsp;&nbsp;<br>&nbsp;Bridge&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Composite&nbsp;<br>&nbsp;Decorator&nbsp;<br>&nbsp;Facade&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Flyweight&nbsp;<br>&nbsp;Proxy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td align=left valign=top>&nbsp;Chain&nbsp;of&nbsp;Responsibility&nbsp;<br>&nbsp;Command&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Mediator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Memento&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Observer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;State&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Strategy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Visitor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr></table><p>按目的分类：</p><dl><dt>创建型</dt><dd>与对象的创建有关。</dd><dt>结构型</dt><dd>处理类或对象的组合。</dd><dt>行为型</dt><dd>对类或对象怎样交互、怎样分配职责进行描述。</dd></dl><p>按范围分类：</p><dl><dt>类模式</dt><dd>处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时就确定下来了。</dd><dt>对象模式</dt><dd>处理对象之间的关系，这些关系在运行时是可以变化的，更具动态性。其实从某种意义上来说，几乎所有模式都使用继承机制，所以『类模式』只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。</dd></dl><p>创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述了一组对象怎样协作完成单个对象所无法完成的任务。</p><h3 id=常见的设计问题及相关模式应用>常见的设计问题及相关模式应用</h3><p>前面在<a href=#open-closed-principle-%e5%bc%80%e9%97%ad%e5%8e%9f%e5%88%99 rel>开闭原则</a>中提到设计应该支持变化，下面介绍一些导致重新设计的一般原因，以及解决这些问题的设计模式：</p><ol><li><p><strong>通过显式指定一个类来创建对象</strong></p><p>在创建对象时指定类名会使得你受到特定实现的约束，而不是特定接口的约束。要避免这种情况，应该间接地创建对象。</p><p>设计模式：<a href=#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82 rel>Abstract Factory 抽象工厂</a>, <a href=#factory-method-%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95 rel>Factory Method 工厂方法</a>, <a href=#prototype-%e5%8e%9f%e5%9e%8b rel>Prototype 原型</a>。</p></li><li><p><strong>对特殊操作的依赖</strong></p><p>当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为了避免把请求代码写死，你应该在编译时或者运行时支持对这种请求的响应方式进行修改。</p><p>设计模式：<a href=#chain-of-responsibility-%e8%b4%a3%e4%bb%bb%e9%93%be rel>Chain of Responsibility 责任链</a>, <a href=#command-%e5%91%bd%e4%bb%a4 rel>Command 命令</a>。</p></li><li><p><strong>对硬件和软件平台的依赖</strong></p><p>外部的操作系统接口和应用编程接口（API）在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。</p><p>设计模式：<a href=#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82 rel>Abstract Factory 抽象工厂</a>, <a href=#bridge-%e6%a1%a5%e6%8e%a5 rel>Bridge 桥接</a>。</p></li><li><p><strong>对对象表示或实现的依赖</strong></p><p>知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。</p><p>设计模式：<a href=#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82 rel>Abstract Factory 抽象工厂</a>, <a href=#bridge-%e6%a1%a5%e6%8e%a5 rel>Bridge 桥接</a>, <a href=#memento-%e5%a4%87%e5%bf%98%e5%bd%95 rel>Memento 备忘录</a>, <a href=#proxy-%e4%bb%a3%e7%90%86 rel>Proxy 代理</a>。</p></li><li><p><strong>算法依赖</strong></p><p>算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的实体在算法发生变化时不得不变化。因此有可能发生变化的算法应该被独立出来。</p><p>设计模式：<a href=#builder-%e7%94%9f%e6%88%90%e5%99%a8 rel>Builder 生成器</a>，<a href=#iterator-%e8%bf%ad%e4%bb%a3%e5%99%a8 rel>Iterator 迭代器</a>，<a href=#strategy-%e7%ad%96%e7%95%a5 rel>Strategy 策略</a>，<a href=#template-method-%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95 rel>Template Method 模板方法</a>，<a href=#visitor-%e8%ae%bf%e9%97%ae%e8%80%85 rel>Visitor 访问者</a>。</p></li><li><p><strong>紧耦合</strong></p><p>紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。</p><p>松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。</p><p>设计模式：<a href=#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82 rel>Abstract Factory 抽象工厂</a>，<a href=#command-%e5%91%bd%e4%bb%a4 rel>Command 命令</a>，<a href=#facade-%e5%a4%96%e8%a7%82 rel>Facade 外观</a>，<a href=#mediator-%e4%b8%ad%e4%bb%8b%e8%80%85 rel>Mediator 中介者</a>，<a href=#observer-%e8%a7%82%e5%af%9f%e8%80%85 rel>Observer 观察者</a>， <a href=#chain-of-responsibility-%e8%b4%a3%e4%bb%bb%e9%93%be rel>Chain of Responsibility 责任链</a>。</p></li><li><p><strong>滥用继承</strong></p><p>通过定义子类来扩充功能是一种比较笨拙的方式，而且极容易导致子类数量爆炸。定义子类还需要对父类有深入的了解，成本较高、容易犯错且耦合紧密。一旦出现两个维度的定制化信息，极容易导致子类数量爆炸，从而导致整个系统变得难以维护。</p><p>对象组合技术是继承之外构建新功能的另一种灵活方法。新的功能可以通过以新的方式组合已有对象来实现。另一方面，过多使用对象组合也可能会导致设计难以理解。因此，许多设计模式往往会将两者结合起来，例如定义一个子类，并将它的实例和已存在实例进行组合来引入定制的功能。</p><p>设计模式：<a href=#bridge-%e6%a1%a5%e6%8e%a5 rel>Bridge 桥接</a>，<a href=#chain-of-responsibility-%e8%b4%a3%e4%bb%bb%e9%93%be rel>Chain of Responsibility 责任链</a>，<a href=#composite-%e7%bb%84%e5%90%88 rel>Composite 组合</a>，
<a href=#decorator-%e8%a3%85%e9%a5%b0%e5%99%a8 rel>Decorator 装饰器</a>，<a href=#observer-%e8%a7%82%e5%af%9f%e8%80%85 rel>Observer 观察者</a>，<a href=#strategy-%e7%ad%96%e7%95%a5 rel>Strategy 策略</a>。</p></li><li><p><strong>不能方便地对类进行修改</strong></p><p>有时你不得不改变一个难以修改的类。也许这个类不属于你维护，你没有源代码，或者对类的修改会导致很多其他依赖方的改动。设计模式提供了在这些情况下对类进行修改的方法。</p><p>设计模式：<a href=#adapter-%e9%80%82%e9%85%8d%e5%99%a8 rel>Adapter 适配器</a>，<a href=#decorator-%e8%a3%85%e9%a5%b0%e5%99%a8 rel>Decorator 装饰器</a>，<a href=#visitor-%e8%ae%bf%e9%97%ae%e8%80%85 rel>Visitor 访问者</a>。</p></li></ol><h3 id=设计模式所支持的设计的可变方面>设计模式所支持的设计的可变方面</h3><table><thead><tr><th>目的</th><th>设计模式</th><th>可变的方面</th></tr></thead><tbody><tr><td>创建</td><td>Abstract Factory</td><td>产品对象家族</td></tr><tr><td></td><td>Builder</td><td>如何创建一个组合对象</td></tr><tr><td></td><td>Factory Method</td><td>被实例化的子类</td></tr><tr><td></td><td>Prototype</td><td>被实例化的类</td></tr><tr><td></td><td>Singleton</td><td>一个类的唯一实例</td></tr><tr><td>结构</td><td>Adapter</td><td>对象的接口</td></tr><tr><td></td><td>Composite</td><td>一个对象的结构和组成</td></tr><tr><td></td><td>Decorator</td><td>对象的职责,不生成子类</td></tr><tr><td></td><td>Facade</td><td>一个子系统的接口</td></tr><tr><td></td><td>Flyweight</td><td>对象的存储开销</td></tr><tr><td></td><td>Proxy</td><td>如何访问一个对象</td></tr><tr><td>行为</td><td>Chain of Responsibility</td><td>响应请求的对象</td></tr><tr><td></td><td>Command</td><td>何时、怎样满足一个请求</td></tr><tr><td></td><td>Interpreter</td><td>一个语言的文法及解释</td></tr><tr><td></td><td>Iterator</td><td>如何遍历、访问一个集合的各元素</td></tr><tr><td></td><td>Mediator</td><td>对象间怎样交互、和谁交互</td></tr><tr><td></td><td>Memento</td><td>一个对象中哪些私有信息存放在该对象之外,以及何时进行存储</td></tr><tr><td></td><td>Observer</td><td>多个对象依赖于另一个对象,而这些对象又如何保持一致</td></tr><tr><td></td><td>State</td><td>对象的状态</td></tr><tr><td></td><td>Strategy</td><td>算法</td></tr><tr><td></td><td>Template Method</td><td>算法中的某些步骤</td></tr><tr><td></td><td>Visitor</td><td>某些可作用于一组对象上的操作，且无需修改这些对象的类</td></tr></tbody></table><h3 id=creational-创建型模式>Creational 创建型模式</h3><h4 id=abstract-factory-抽象工厂>Abstract Factory 抽象工厂</h4><ul><li><p>意图</p><blockquote><p>提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。</p></blockquote></li></ul><ul><li><p>案例</p><p>前面在<a href=#dependency-inversion-principle-%e4%be%9d%e8%b5%96%e5%80%92%e7%bd%ae%e5%8e%9f%e5%88%99 rel>依赖倒置原则</a>中，其实已经举过一个贴纸的例子，可以视为抽象工厂的简化版本，其思路是一致的。</p><p>除了对 <code>Product</code> 和 <code>Factory</code> 进行抽象以外，抽象工厂方法会更加强调 <strong>产品系列</strong> 的概念。比如《设计模式》一书中经典的例子，支持多种视感(look-and-feel)标准的用户界面，不同的视感风格为诸如滚动条、窗口和按钮等用户界面『窗口组件』定义不同的外观和行为。而某个特定视感风格下的一系列『窗口组件』，就是一个产品系列。我们不应该在 Motif
风格的窗口组件中，混入一个 PM 风格的窗口组件。</p><p>这里我们需要解决两个问题：</p><ul><li>如何确保软件不依赖某种具体的视感风格，以保证软件的可移植性。就像前面的案例中，
<code>Editor</code> 不应该直接依赖某个具体的 <code>StaticSticker</code> 一样；</li><li>如何确保我们不会在 Motif 视感中，错误的使用了一个 PM 风格的组件？</li></ul><p>我们可以通过抽象工厂模式，优雅地解决上述两个问题。看一下类图就明白了：</p><figure><img src=/ox-hugo/class-diagram-widget-factory.png></figure><p>每一种视感标准都对应一个具体的 <code>WidgetFactory</code> 子类，客户只需要通过 <code>WidgetFactory</code>
即可创建出一组特定风格的窗口组件，无需关心哪些类实现了特定风格的窗口组件，而且可以保证绝对不会错误的混用不同风格的窗口，因为 <code>WidgetFactory</code> 强化了同一类型风格组件之间的绑定关系。</p></li></ul><ul><li><p>适用性</p><ul><li>一个系统希望独立于它的产品的创建、组合和实现。</li><li>一个系统存在多个产品系列，在工作时需要选择其中一个产品系列来使用。</li><li>比较强调产品系列的概念，同一个系列的产品应该配合在引起使用，不同系列的产品不能混用。</li><li>提供一个产品类库，但只想暴露它们的接口而不是实现。</li></ul></li></ul><ul><li><p>优点</p><ul><li>它分离了具体实现类</li><li>替换产品系列变得十分简单，只需替换一个 factory 即可</li><li>有利于产品的一致性，可以自动确保不同系列的产品之间不会混用</li></ul></li></ul><ul><li><p>缺点</p><p>该模式可以很轻易的扩展新的产品系列，但如果要扩展产品系列中的产品类型，例如上述案例中，增加一种新的窗口组件，会比较困难，因为会涉及 <code>AbstractFactory</code> 类及其所有子类的修改。</p><p>因此，使用该模式最好一开始就考虑清楚系统中有哪些产品类型，是否相对稳定，否则不太建议使用。</p></li></ul><h4 id=factory-method-工厂方法>Factory Method 工厂方法</h4><ul><li><p>意图</p><blockquote><p>定义一个用于创建对象的接口，让子类决定具体将创建哪一种类型的实例，即对象的实例化过程被延迟到子类进行。</p></blockquote><p>工厂方法相对比较简单，其实在<a href=#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82 rel>Abstract Factory 抽象工厂</a>中就有工厂方法的运用。</p></li></ul><ul><li><p>类图</p><figure><img src=/ox-hugo/factory-method-class.png></figure></li></ul><h4 id=builder-生成器>Builder 生成器</h4><ul><li><p>意图</p><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote></li></ul><ul><li><p>类图</p><figure><img src=/ox-hugo/builder-class.png></figure></li></ul><ul><li><p>时序图</p><figure><img src=/ox-hugo/builder-sequence.png></figure></li></ul><h4 id=prototype-原型>Prototype 原型</h4><ul><li><p>意图</p><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote></li></ul><ul><li><p>类图</p><figure><img src=/ox-hugo/prototype-class.png></figure></li></ul><h3 id=structural-结构型模式>Structural 结构型模式</h3><h4 id=adapter-适配器>Adapter 适配器</h4><ul><li><p>意图</p><blockquote><p>将一个类的接口转换成客户希望的另外一个接口，使得原本不兼容的模块之间可以协同工作。</p></blockquote></li></ul><ul><li><p>类图</p><figure><img src=/ox-hugo/adapter-class.png></figure></li></ul><ul><li><p>相关模式</p><p>和 <a href=#bridge-%e6%a1%a5%e6%8e%a5 rel>Bridge 桥接</a> 有点类似，但是出发点不同：</p><ul><li>Bridge 的目的是将接口部分和实现部分分离，从而可以对它们较为容易也相对独立地加以改变。</li><li>Adapter 意味着改变一个已有对象的接口。</li></ul><p><a href=#decorator-%e8%a3%85%e9%a5%b0%e5%99%a8 rel>Decorator 装饰器</a> 在不改变接口的情况下，增强了其他对象的功能，因此 Decorator 对应用程序的透明性比较好，而且可以支持递归组合。</p><p><a href=#proxy-%e4%bb%a3%e7%90%86 rel>Proxy 代理</a> 在不改变它的接口的条件下，为另一个对象定义了一个代理。</p></li></ul><h4 id=bridge-桥接>Bridge 桥接</h4><ul><li><p>意图</p><blockquote><p>将抽象部分与它的实现部分分离，使它们可以独立地变化。</p></blockquote></li></ul><ul><li><p>类图</p><figure><img src=/ox-hugo/bridge-class.png></figure><p>上图中 <code>Window</code> 和 <code>WindowImp</code> 之间就是 Bridge 的关系。</p></li></ul><h4 id=composite-组合>Composite 组合</h4><ul><li><p>意图</p><blockquote><p>将对象组合成树形结构以表示“部分－整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote></li></ul><ul><li><p>类图</p><figure><img src=/ox-hugo/composite-class.png></figure></li></ul><h4 id=decorator-装饰器>Decorator 装饰器</h4><h4 id=facade-外观>Facade 外观</h4><h4 id=flyweight-享元>Flyweight 享元</h4><ul><li><p>意图</p><blockquote><p>运用共享技术有效地支持大量细粒度的对象。</p></blockquote></li></ul><ul><li><p>适用性</p><p>当以下情况都成立时，可以使用 Flyweight 模式：</p><ul><li>一个应用程序使用了大量的对象。</li><li>完全由于使用大量的对象造成很大的内存开销。</li><li>对象的大多数状态都可以变为外部状态。</li><li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</li><li>应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以两个逻辑上不同的对象，其物理上可能是同一个对象，因此应用程序不应该依赖对象标识的比较。</li></ul></li></ul><ul><li><p>结构</p><figure><img src=/ox-hugo/flyweight-class.png></figure></li></ul><ul><li><p>相关模式</p><p>在实现 <a href=#state-%e7%8a%b6%e6%80%81 rel>State 状态</a> 模式和 <a href=#strategy-%e7%ad%96%e7%95%a5 rel>Strategy 策略</a> 模式时，如果涉及状态或策略较多的，可以考虑采用 Flyweight 模式来实现。</p></li></ul><h4 id=proxy-代理>Proxy 代理</h4><ul><li><p>意图</p><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote></li></ul><ul><li><p>适用性</p><ul><li><p>远程代理（Remote Proxy）</p><p>为一个对象在不同的地址空间提供局部代表。Android 的 <code>AIDL</code> 生成的 <code>Stub.Proxy</code> 类就是这样一种代理。</p></li></ul><ul><li><p>虚代理（Virtual Proxy）</p><p>按需创建开销较大的对象。</p><ul><li><p><em>Copy-on-write</em> (COW) 优化</p><p>这里拓展一下，还可以实现透明的 <em>copy-on-write</em> 优化。拷贝一个庞大而复杂的对象是一种开销很大的操作，如果这个拷贝根本没有被修改，那么这些开销就没有必要。用代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改的时候才对它进行拷贝。</p></li></ul></li></ul><ul><li><p>保护代理（Protection Proxy）</p><p>控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</p></li></ul><ul><li><p>智能引用（Smart Reference）</p><p>取代简单的指针，它在访问对象时执行一些附加操作，典型用途包括：</p><ul><li>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为 Smart Pointer）。</li><li>当第一次引用一个持久对象时，将它装入内存。</li><li>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li></ul></li></ul><ul><li><p>结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Proxy
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      +--------+                  +---------+
</span></span><span class=line><span class=cl>      | Client +-----------------&gt;+ Subject |
</span></span><span class=line><span class=cl>      +--------+                  +---------+
</span></span><span class=line><span class=cl>                                  | request |
</span></span><span class=line><span class=cl>                                  | ...     |
</span></span><span class=line><span class=cl>                                  +---------+
</span></span><span class=line><span class=cl>                                       ᐞ
</span></span><span class=line><span class=cl>           +---------------------------+
</span></span><span class=line><span class=cl>           |                           |
</span></span><span class=line><span class=cl>   +-------+-----+   realSubject  +----+----+
</span></span><span class=line><span class=cl>   | RealSubject +&lt;---------------+ Proxy   |      +------------------------+
</span></span><span class=line><span class=cl>   +-------------+                +---------+      |  ...                   |
</span></span><span class=line><span class=cl>   |  request    |                | request +------+  realSubject.request() |
</span></span><span class=line><span class=cl>   |  ...        |                | ...     |      |  ...                   |
</span></span><span class=line><span class=cl>   +-------------+                +---------+      +------------------------+
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>相关模式</p><ul><li><a href=#adapter-%e9%80%82%e9%85%8d%e5%99%a8 rel>Adapter 适配器</a>: 适配器为它所适配的对象提供一个不同的接口。相反，代理提供与它的实体相同的接口。</li><li><a href=#decorator-%e8%a3%85%e9%a5%b0%e5%99%a8 rel>Decorator 装饰器</a>: 装饰的实现部分和代理有点类似，但是目的不同。装饰为对象添加一个或多个功能，而代理则控制对对象的访问。另外实现上虽然有相似之处，但还是有些细微的差异。例如，Remote Proxy 并不包含对实体的直接引用，而只是一个间接引用（例如
Android <code>AIDL</code> 的例子）。</li></ul></li></ul></li></ul><h3 id=behavioral-行为型模式>Behavioral 行为型模式</h3><h4 id=chain-of-responsibility-责任链>Chain of Responsibility 责任链</h4><h4 id=command-命令>Command 命令</h4><ul><li><p>意图</p><blockquote><p>将某种请求封装为一个对象，换句话说，将请求参数化，这样可以解耦请求的创建方和实现方，也方便对请求进行排队、记录日志，以及支持撤销等操作。</p></blockquote></li></ul><ul><li><p>结构</p><figure><img src=/ox-hugo/command-class.png></figure></li></ul><ul><li><p>用法介绍</p><ul><li><p>实现菜单、按钮功能</p><p>Command 模式特别适合用来实现菜单、按钮的功能。用 Command 模式实现有如下好处：</p><ul><li>可以很方便的让一个菜单和一个按钮代表同一项功能，只需让二者共享同一个 Command
对象即可。</li><li>可以很轻松的动态替换某项菜单或按钮的功能（例如实现上下文有关的菜单），只需动态替换 Command 对象即可。</li><li>还可以很方便将若干个命令组合成一个更大的命令，实现命令脚本（command scripting）功能。参考 <a href=#macrocommand-%e5%ae%8f%e5%91%bd%e4%bb%a4 rel>MacroCommand 宏命令</a>。</li></ul></li></ul><ul><li><p>MacroCommand 宏命令</p><p><code>MacroCommand</code> 是一个具体的 <code>Command</code> 子类，它用来执行一个命令序列。 <code>MacroCommand</code> 运用了<a href=#composite-%e7%bb%84%e5%90%88 rel>Composite 组合</a>模式来实现这种层次结构，参考下面的类图：</p><figure><img src=/ox-hugo/macro-command-class.png></figure></li></ul></li></ul><ul><li><p>协作</p><figure><img src=/ox-hugo/command-sequence.svg></figure></li></ul><ul><li>相关模式</li></ul><h4 id=iterator-迭代器>Iterator 迭代器</h4><h4 id=mediator-中介者>Mediator 中介者</h4><h4 id=memento-备忘录>Memento 备忘录</h4><ul><li><p>意图</p><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p></blockquote></li></ul><ul><li><p>结构</p><figure><img src=/ox-hugo/memento-class.png></figure><ul><li><p>Memento 备忘录</p><ul><li>备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。</li><li>防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者（Caretaker）只能看到备忘录的 <strong>窄接口</strong> （只能将备忘录传递给其他对象），而原发器能够看到一个​<strong>宽接口</strong>, 允许它访问恢复到先前状态所需的所有数据。</li></ul></li></ul><ul><li><p>Originator 原发器</p><ul><li>原发器创建一个备忘录，用以记录当前时刻它的内部状态。</li><li>使用备忘录恢复内部状态。</li></ul></li></ul><ul><li><p>Caretaker 管理者，例如“撤销机制”</p><ul><li>负责保存好备忘录</li><li>不能对备忘录的内容进行操作或检查。</li></ul></li></ul></li></ul><ul><li><p>相关模式</p><ul><li><a href=#command-%e5%91%bd%e4%bb%a4 rel>Command 命令</a>: 命令可使用备忘录来为可撤销的操作维护状态。</li><li><a href=#iterator-%e8%bf%ad%e4%bb%a3%e5%99%a8 rel>Iterator 迭代器</a>: 备忘录可用于迭代器的实现，用于存储迭代器的当前状态。</li></ul></li></ul><h4 id=observer-观察者>Observer 观察者</h4><h4 id=state-状态>State 状态</h4><h4 id=strategy-策略>Strategy 策略</h4><h4 id=template-method-模板方法>Template Method 模板方法</h4><h4 id=visitor-访问者>Visitor 访问者</h4></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-07-01</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://mincodes.com/posts/design-patterns/ data-title=软件设计原则、设计模式总结 data-hashtags=design-pattern,architecture,android><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://mincodes.com/posts/design-patterns/ data-hashtag=design-pattern><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://mincodes.com/posts/design-patterns/ data-title=软件设计原则、设计模式总结><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://mincodes.com/posts/design-patterns/ data-title=软件设计原则、设计模式总结><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://mincodes.com/posts/design-patterns/ data-title=软件设计原则、设计模式总结><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/design-pattern/>design-pattern</a>,&nbsp;<a href=/tags/architecture/>architecture</a>,&nbsp;<a href=/tags/android/>android</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/android-binder/ class=prev rel=prev title="Android 的 Binder 机制"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Android 的 Binder 机制</a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Min Deng</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{},data:{"id-1":"MinCodes","id-2":"MinCodes"},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:100}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EPY7LC720X",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-EPY7LC720X" async></script></body></html>