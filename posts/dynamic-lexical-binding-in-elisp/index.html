<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>动态绑定（Dynamic Binding）和词法绑定（Lexical Binding） - MinCodes</title><meta name=Description content="MinCodes, Minimal but useful Codes"><meta property="og:title" content="动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）">
<meta property="og:description" content="今天读了一篇讲 dynamic binding 和 lexical binding 的文章： Dynamic Binding Vs Lexical Binding，讲的挺清楚的，这里大致翻译如下。 绑定 binding 的概念 绑定是名字和值的一种对应关系。在 Lisp 中，可"><meta property="og:type" content="article"><meta property="og:url" content="https://mincodes.com/posts/dynamic-lexical-binding-in-elisp/"><meta property="og:image" content="https://mincodes.com/favicon.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-26T14:42:00+08:00"><meta property="article:modified_time" content="2023-06-26T15:24:47+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mincodes.com/favicon.svg"><meta name=twitter:title content="动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）"><meta name=twitter:description content="今天读了一篇讲 dynamic binding 和 lexical binding 的文章： Dynamic Binding Vs Lexical Binding，讲的挺清楚的，这里大致翻译如下。 绑定 binding 的概念 绑定是名字和值的一种对应关系。在 Lisp 中，可"><meta name=application-name content="MinCodes"><meta name=apple-mobile-web-app-title content="MinCodes"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://mincodes.com/posts/dynamic-lexical-binding-in-elisp/><link rel=prev href=https://mincodes.com/posts/bash-set/><link rel=next href=https://mincodes.com/posts/android-binder/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/mincodes.com\/posts\/dynamic-lexical-binding-in-elisp\/"},"genre":"posts","keywords":"elisp, emacs","wordcount":1740,"url":"https:\/\/mincodes.com\/posts\/dynamic-lexical-binding-in-elisp\/","datePublished":"2023-06-26T14:42:00+08:00","dateModified":"2023-06-26T15:24:47+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Min Deng"},"description":""}</script><script src=https://mincodes.com/js/mathjax-config.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=MinCodes><img class="lazyload logo" src=/svg/loading.min.svg data-src=/favicon.svg data-srcset="/favicon.svg, /favicon.svg 1.5x, /favicon.svg 2x" data-sizes=auto alt=/favicon.svg title=/favicon.svg><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>posts </a><a class=menu-item href=/tags/tools>tools </a><a class=menu-item href=/tags/>tags </a><a class=menu-item href=/about/>about </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=MinCodes><img class="lazyload logo" src=/svg/loading.min.svg data-src=/favicon.svg data-srcset="/favicon.svg, /favicon.svg 1.5x, /favicon.svg 2x" data-sizes=auto alt=/favicon.svg title=/favicon.svg><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>posts</a><a class=menu-item href=/tags/tools title>tools</a><a class=menu-item href=/tags/ title>tags</a><a class=menu-item href=/about/ title>about</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Min Deng</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-06-26>2023-06-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 1740 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#绑定-binding-的概念>绑定 binding 的概念</a></li><li><a href=#动态绑定和词法绑定>动态绑定和词法绑定</a></li><li><a href=#动态绑定的优点>动态绑定的优点</a></li><li><a href=#词法绑定的优点>词法绑定的优点</a></li><li><a href=#语言>语言</a></li><li><a href=#使用词法绑定>使用词法绑定</a></li></ul></nav></div></div><div class=content id=content><p>今天读了一篇讲 dynamic binding 和 lexical binding 的文章： <a href=https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding target=_blank rel="noopener noreffer">Dynamic Binding Vs
Lexical Binding</a>，讲的挺清楚的，这里大致翻译如下。</p><h2 id=绑定-binding-的概念>绑定 binding 的概念</h2><p>绑定是名字和值的一种对应关系。在 Lisp 中，可以用 <code>let</code> 来创建绑定：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl>  <span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>a</span> <span class=mi>1</span><span class=p>))</span> <span class=p>(</span><span class=nf>print</span> <span class=nv>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; ==&gt; 1</span>
</span></span></code></pre></td></tr></table></div></div><p>这里将 name <code>a</code> 绑定到 value <code>1</code> 上。</p><p><code>let</code> 表达式其实只是一个“语法糖”，和 <code>lambda</code> 表达式是等价的。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl>  <span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>a</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nv>b</span> <span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>等价于：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl>  <span class=p>((</span><span class=nb>lambda</span> <span class=p>(</span><span class=nv>a</span> <span class=nv>b</span><span class=p>)</span> <span class=p>(</span><span class=nf>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))</span> <span class=mi>1</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>当然，除了 <code>let</code> 之外，还有很多其他的方法可以创建 bindings, 例如 <code>defconst</code>, <code>defun</code>,
<code>defvar</code>, <code>flet</code>, <code>labels</code>, <code>prog</code>, 等等。</p><h2 id=动态绑定和词法绑定>动态绑定和词法绑定</h2><p>在处理变量绑定时，有两种方式：</p><dl><dt>dynamic</dt><dd>动态绑定，所有的变量名及它们的值都存在一张全局表中。</dd><dt>lexical</dt><dd>词法绑定，每个绑定作用域（binding scope），包括 defun/let 等，都会创建一张新的表，用于存放变量和值，这些表组织成一个层次结构，被称为 &ldquo;the enviroment&rdquo;。</dd></dl><p>在上面给出的那些简单的例子中，lexical 和 dynamic binding 之间并没有什么区别，返回的结果是一样的。</p><p>但是在一些复杂情况下，情况则有所不同。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl>  <span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>a</span> <span class=mi>1</span><span class=p>))</span>                            <span class=c1>; binding (1)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>f</span> <span class=p>(</span><span class=nb>lambda</span> <span class=p>()</span> <span class=p>(</span><span class=nf>print</span> <span class=nv>a</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>a</span> <span class=mi>2</span><span class=p>))</span>                        <span class=c1>; binding (2)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>funcall</span> <span class=nv>f</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; dynamic binding ==&gt; 2</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; lexical binding ==&gt; 1</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>如果是 <strong>lexical binding</strong> ，在访问变量时，会在 <strong>lexical enviroment</strong> 中查找绑定，也就是说，在变量的代码块范围内查找。当在 <strong>lexical enviroment</strong> 中有多个绑定同时存在时，选择最内层的那个。</p><p>因此，如果是 lexical binding，上述代码会打印 “1”，因为只有 binding (1) 在
lexical enviroment 中。</p></li><li><p>如果是 <strong>dynamic binding</strong>, 在访问变量时只会在 <strong>dynamic enviroment</strong> 中查找，也就是说，在所有的绑定中查找，包括从程序启动之后创建的所有绑定（只要没被销毁）。如果同时存在多个绑定，则使用运行时最近创建的那个（我想这就是 <strong>dynamic</strong> 一词的由来）。</p><p>因此，如果是 dynamic binding，上述代码会打印 “2”，因为当 <code>a</code> 求值时，binding
(1) 和 binding (2) 都被创建了，但是 binding (2) 才是最近创建的。</p><blockquote><p>在多线程 Lisp 中，关于 dynamic binding 我们需要更加小心一点，因为要确保一个线程不会看到（访问到）另一个线程所创建的 bindings。由于 EmacsLisp 是单线程的，所以不用担心。</p></blockquote></li></ul><h2 id=动态绑定的优点>动态绑定的优点</h2><p>动态绑定可以很方便的修改子系统的行为。</p><p>这里举一个例子。假设你有一个 <code>foo</code> 的函数，该函数会利用 <code>print</code> 产生一些输出，你希望可以将该输出捕获到一个 buffer 中。通过 dynamic binding，可以很轻松的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl>  <span class=c1>;; get-buffer-create 获取或创建一个指定名字的 buffer，注意名字前面有一个空格，表</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; 示该 buffer 不保留 undo 历史</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>b</span> <span class=p>(</span><span class=nf>get-buffer-create</span> <span class=s>&#34; *string-output*&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=c1>;; 修改 standard-output 变量，将标准输出重定向到 buffer b 中。注意：该修改仅在</span>
</span></span><span class=line><span class=cl>    <span class=c1>;; 该 let 的作用域范围内生效</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>standard-output</span> <span class=nv>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=c1>;; 该输出会重定向到 buffer b 中</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>print</span> <span class=s>&#34;foo&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; 切换当前 buffer 为 b，仅用于编辑，不会展示该 buffer</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>set-buffer</span> <span class=nv>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>insert</span> <span class=s>&#34;bar&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>;; 返回当前 buffer 的内容</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>buffer-string</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>如果你经常使用类似的功能，你应该将其封装在一个 macro 中 —— 幸运的是，已经有这样的封装了： <code>with-output-to-temp-buffer</code> 。</p></blockquote><p>由于 <code>foo</code> （这里其实是 <code>print</code> 函数）使用的 <code>standard-output</code> 是 <em>dynamic binding</em> 的，因此你可以替换成你自己的绑定，以此来修改 <code>foo</code> 的行为 —— 以及 <code>foo</code> 所调用的所有
functions 的行为。</p><p>在一个不支持 dynamic binding 的语言中，你大概需要给 <code>foo</code> 增加一个可选参数来指定一个 buffer，然后 <code>foo</code> 需要传递该参数给所有的 <code>print</code> 调用。如果 <code>foo</code> 还调用了其他函数，并且这些函数也调用了 <code>print</code> ，那么你同样需要修改所有这些参数（注意：这是一个递归的过程）。</p><p>Richard Stallman 在 EmacsLisp 的上下文中解释了动态绑定的优点：<a href=https://www.gnu.org/software/emacs/emacs-paper.html#SEC17 target=_blank rel="noopener noreffer">Emacs Paper - Dynamic
Binding</a> 。另请参阅 Pascal Costanza 写的文章 <a href=http://www.p-cos.net/documents/dynatype.pdf target=_blank rel="noopener noreffer">Dynamic vs. Static Typing — A
Pattern-Based Analysis</a> 。</p><h2 id=词法绑定的优点>词法绑定的优点</h2><p>MilesBader 的这封邮件讲的很清楚，这里摘抄并翻译如下：</p><blockquote><div class=verse><p>From: MilesBader<br>Subject: Re: Emacs 22<br>Newsgroups: comp.emacs<br>Date: Sun, 19 Aug 2001 01:47:53 GMT<br></p></div><p>Because it&rsquo;s (1) much easier for the user [that is, programmer], because it
eliminates the problem of which variables lambda-expressions use (when they
attempt to use variables from their surrounding context), and (2) much easier
for the compiler to optimize, because it doesn&rsquo;t need to worry about variables
escaping their lexical context, and so doesn&rsquo;t need to allow for the possibility
(this is a big problem with the current compiler).</p><p>因为它（1）对于程序员来讲，要简单很多，因为它消除了 lambda 表达式使用哪些变量的问题（当他们尝试使用外围环境的变量时），（2）对于编译器来说，优化起来要简单很多，因为它不需要担心变量从词法上下文中逃逸出去，因此不需要考虑这种逃逸出去的可能性（这是当前编译器的一个大问题）。</p></blockquote><h2 id=语言>语言</h2><p>大部分语言只支持 lexical binding 。</p><ul><li>EmacsLisp 从 24.1 版本开始同时支持 dynamic binding 和 lexical binding 。
Lexical binding 需要在一个文件或 buffer 中显式启用（见下文）。通过 <code>defvar</code> 定义的变量为“special”变量，即永远是动态绑定的（即使该文件启用了 lexical binding）。</li><li>CommonLisp 同时支持 dynamic binding 和 lexical binding 。 默认为 lexical
binding，通过 <code>defvar</code> 或 <code>declare</code> 创建的一个变量即为“special”的动态绑定变量。</li></ul><h2 id=使用词法绑定>使用词法绑定</h2><p>要在 EmacsLisp 中使用词法绑定，需要在文件头中设置 file-local 变量
<code>lexical-binding</code> 为 <code>t</code> ，且必须在文件的第一行中设置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl>  <span class=c1>;;; -*- lexical-binding: t -*-</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-06-26</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://mincodes.com/posts/dynamic-lexical-binding-in-elisp/ data-title="动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）" data-hashtags=elisp,emacs><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://mincodes.com/posts/dynamic-lexical-binding-in-elisp/ data-hashtag=elisp><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://mincodes.com/posts/dynamic-lexical-binding-in-elisp/ data-title="动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://mincodes.com/posts/dynamic-lexical-binding-in-elisp/ data-title="动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://mincodes.com/posts/dynamic-lexical-binding-in-elisp/ data-title="动态绑定（Dynamic Binding）和词法绑定（Lexical Binding）"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/elisp/>elisp</a>,&nbsp;<a href=/tags/emacs/>emacs</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/bash-set/ class=prev rel=prev title="Bash: set 命令用法介绍"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Bash: set 命令用法介绍</a>
<a href=/posts/android-binder/ class=next rel=next title="Android 的 Binder 机制">Android 的 Binder 机制<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Min Deng</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{},data:{"id-1":"MinCodes","id-2":"MinCodes"},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:100}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EPY7LC720X",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-EPY7LC720X" async></script></body></html>