<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - MinCodes</title><link>https://mincodes.com/posts/</link><description>所有文章 | MinCodes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 03 Jul 2023 18:00:38 +0800</lastBuildDate><atom:link href="https://mincodes.com/posts/" rel="self" type="application/rss+xml"/><item><title>软件设计原则、设计模式总结</title><link>https://mincodes.com/posts/design-patterns/</link><pubDate>Mon, 03 Jul 2023 16:40:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns/</guid><description>前言 本文是笔者对软件设计原则、设计模式的一个梳理，很多内容参考自《设计模式：可复用面向对象软件的基础》一书（尤其是设计模式部分）。其中也包含</description></item><item><title>设计模式：装饰器 (Decorator)</title><link>https://mincodes.com/posts/design-patterns-decorator/</link><pubDate>Mon, 03 Jul 2023 18:00:38 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-decorator/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。</description></item><item><title>设计模式：访问者 (Visitor)</title><link>https://mincodes.com/posts/design-patterns-visitor/</link><pubDate>Mon, 03 Jul 2023 17:37:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-visitor/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 当我们遍历一个对象结构的元素时，该模式允许我们在不修改各个元素的类结构的前提下，为</description></item><item><title>设计模式：备忘录 (Memento)</title><link>https://mincodes.com/posts/design-patterns-memento/</link><pubDate>Mon, 03 Jul 2023 17:35:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-memento/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以</description></item><item><title>设计模式：命令 (Command)</title><link>https://mincodes.com/posts/design-patterns-command/</link><pubDate>Mon, 03 Jul 2023 17:34:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-command/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 将某种请求封装为一个对象，换句话说，将请求参数化，这样可以解耦请求的创建方和实现方</description></item><item><title>设计模式：代理 (Proxy)</title><link>https://mincodes.com/posts/design-patterns-proxy/</link><pubDate>Mon, 03 Jul 2023 17:31:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-proxy/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 为其他对象提供一种代理以控制对这个对象的访问。 不同类型的代理 远程代理（Remote</description></item><item><title>设计模式：享元 (Flyweight)</title><link>https://mincodes.com/posts/design-patterns-flyweight/</link><pubDate>Mon, 03 Jul 2023 17:29:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-flyweight/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 运用共享技术有效地支持大量细粒度的对象。 适用性 当以下情况都成立时，可以使用 Flyweight 模式：</description></item><item><title>设计模式：组合 (Composite)</title><link>https://mincodes.com/posts/design-patterns-composite/</link><pubDate>Mon, 03 Jul 2023 17:25:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-composite/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 将对象组合成树形结构以表示“部分－整体”的层次结构。Composite 使得用户对单</description></item><item><title>设计模式：桥接 (Bridge)</title><link>https://mincodes.com/posts/design-patterns-bridge/</link><pubDate>Mon, 03 Jul 2023 17:24:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-bridge/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 将抽象部分与它的实现部分分离，使它们可以独立地变化。 类图 上图中 Window 和 WindowImp 之间就是 Bridge 的关</description></item><item><title>设计模式：适配器 (Adapter)</title><link>https://mincodes.com/posts/design-patterns-adapter/</link><pubDate>Mon, 03 Jul 2023 17:20:00 +0800</pubDate><author>Min Deng</author><guid>https://mincodes.com/posts/design-patterns-adapter/</guid><description>设计模式总目录请参考：设计模式所支持的设计的可变方面。 意图 将一个类的接口转换成客户希望的另外一个接口，使得原本不兼容的模块之间可以协同工作。</description></item></channel></rss>