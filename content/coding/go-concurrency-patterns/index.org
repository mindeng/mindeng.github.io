# -*- mode: Org; org-download-image-dir: "./"; org-download-heading-lvl: nil; -*-
#+TITLE: Go 并发模式总结
#+tags[]: golang concurrency goroutine
#+date: 2022-03-09

* Generator 发生器

Generator 指返回一个 chan 的函数。这是一种十分常见的使用 goroutine +
chan 的方式，可以说是一种标准用法了。

采用这种方式使用 chan 十分的安全，不会出现一些 chan 误用导致的错误（例
如向已经关闭的 chan 写入数据等）。

例如下面的代码，会开一个 goroutine 递归遍历指定目录，并将目录下的所有
json 文件通过 chan 吐出去。
#+begin_src go
  func walkJsonFiles(dir string) <-chan string {
	  out := make(chan string)

	  go func() {
		  defer close(out)

		  err := filepath.WalkDir(dir,
			  func(path string, info fs.DirEntry, err error) error {

				  if err != nil {
					  log.Printf("can't access path: %q: %v\n", path, err)
					  return err
				  }

				  if !info.Type().IsDir() && filepath.Ext(path) == ".json" {
					  out <- path
				  }

				  return nil
			  })

		  if err != nil {
			  log.Printf("error walking the path %q: %v\n", trace_file_dir, err)
			  return
		  }
	  }()

	  return out
  }
#+end_src

* Multiplexing 多路复用（Fan-In）

下面这张图可以形象的表达 Fan-In 的概念：

#+DOWNLOADED: screenshot @ 2022-03-09 21:22:37
[[file:2022-03-09_21-22-37_screenshot.png]]

** Fan-In: 多 goroutine 版本

#+begin_src go
  func fanIn(cs ...<-chan string) <-chan string {
	  out := make(chan string)
	  var wg sync.WaitGroup

	  // 注意：这里不能直接 wg.Wait()，需要开一个 goroutine 来 Wait
	  defer func() {
		  go func() {
			  wg.Wait()
			  close(out)
		  }()
	  }()

	  collect := func(in <-chan string) {
		  defer wg.Done()
		  for n := range in {
			  out <- n
		  }
	  }

	  wg.Add(len(cs))

	  // Fan-In
	  for _, c := range cs {
		  go collect(c)
	  }

	  return out
  }
#+end_src

** Fan-In: select 版本

#+begin_src go

  func fanInUsingSelect(input1, input2 <-chan string) <-chan string {
	  out := make(chan string)

	  go func() {
		  defer close(out)
		
		  for {
			  select {
			  case x, ok := <-input1:
				  if !ok {
					  input1 = nil
				  } else {
					  out <- x
				  }
			  case x, ok := <-input2:
				  if !ok {
					  input2 = nil
				  } else {
					  out <- x
				  }
			  }

			  if input1 == nil && input2 == nil {
				  break
			  }
		  }
	  }()

	  return out
  }
#+end_src

* Fan-Out

Fan-Out 刚好和 Fan-In 相反，一般和 Fan-In 配合起来一起使用：

#+begin_src go
  func processJsonFiles(ch <-chan string) <-chan {
	  out := make(chan string)

	  go func() {
		  defer close(out)

		  for s := range ch {
			  // do something useful ...
			  out <- s + " done"
		  }
	  }()

	  return out
  }

  func fanOut(in <-chan string) <-chan string {
	  // 同时开 n 个 goroutine 来处理这些 json files
	  n := 20
	  cs := make([]<-chan string, n)
	  for i := 0; i < n; i++ {
		  cs[i] = processJsonFiles(ch)
	  }

	  out := fanIn(cs...)

	  return out
  }

  func main() {
	  ch := walkJsonFiles("./")
	  out := fanOut(ch)

	  for s := range out {
		  fmt.Println(s)
	  }
  }
#+end_src

* select 实现 Timeout

* Quit chan
