+++
title = "Rust 的 move 和 C++ 的 std::move"
date = 2024-03-06T12:19:00+08:00
lastmod = 2024-03-06T13:44:37+08:00
tags = ["rust"]
draft = false
+++

Rust 的 `move` 和 C++ 的 `std::move` 在表面上看有些相似之处，因为它们都涉及到数据或资源的转移。然而，它们在设计理念、实现方式以及它们在各自语言中所扮演的角色上有着根本的区别。


## Rust 中的 Move 语义 {#rust-中的-move-语义}

所有权转移
: Rust 中的 move 语义是其所有权系统的核心部分。当一个值从一个变量移动到另一个变量时，原始变量不再有权访问该值。这避免了悬垂指针和数据竞争等问题。

编译时检查
: Rust 的编译器在编译时就会检查所有权、借用和生命周期规则，确保内存安全而无需运行时开销。

自动控制
: Rust 的 move 语义是通过编译器自动实现的，不需要程序员提供特殊的代码来支持 move
    语义。


## C++ 中的 Move 语义 {#c-plus-plus-中的-move-语义}

资源转移
: C++11 引入了 move 语义，主要用于优化资源管理，减少不必要的对象复制。通过
    `std::move` ，可以将一个对象的状态或资源转移到另一个对象，原对象则处于一个有效但未定义的状态。

标准库的支持
: C++ 的 move 语义与其标准库紧密结合，许多容器和算法都对 move 语义进行了优化。

手动控制
: 与 Rust 的自动和严格的所有权模型不同，C++ 程序员需要更多地手动管理资源和使用
    move 语义，这提供了灵活性但也增加了错误的可能性。

    具体来讲，C++ 的 move 语义是通过类的『移动构造函数』和『移动赋值运算符』来提供支持的。


## 异同点分析 {#异同点分析}

设计理念
: Rust 的 move 语义设计主要是为了实现内存安全和线程安全，而 C++ 的 move 语义更多是为了性能优化和资源管理。

实现机制
: Rust 在编译时强制执行所有权规则，几乎不允许违反这些规则的代码通过编译。而 C++
    给了程序员更多的控制权，但这也意味着更高的出错风险。

使用场景
: Rust 的 move 用于所有权转移，强调安全和清晰的所有权模型。C++ 的 move 更多是用于性能优化，尤其是在处理大型对象或资源密集型对象时。


## 深入到内存层面 {#深入到内存层面}

如果我们深入到内存层面，就会发现，Rust 的 move 和 C++ 的 move 又有一些相似之处。

就内存操作而言，Rust 中的 move 过程本质上是对数据结构的浅拷贝[^fn:1]。以 `Vec<T>` 为例，
move 操作涉及到的只是对数据结构内部字段（指针、长度和容量等）的拷贝，而不会触及堆上的数据本身。这点和 C++ 的『移动构造函数』的实现很相似，区别在于：

-   C++ 在浅拷贝之后，需要将原始对象的字段重置，以防止析构函数多次释放资源。
-   Rust 则直接通过编译器保证原始对象不再可用，在安全性上更胜一筹。

当然，如前所述，整个过程 Rust 是自动完成的，而 C++ 需要由程序员来手工完成。


## 总结 {#总结}

综上所述，Rust 的 move 和 C++ 的 move 在设计理念、实现机制和使用场景方面都存在较大差异，但两者在资源转移方面又有一些相似之处，例如都可以通过浅拷贝来完成资源的高效转移。通过这种对比分析，我们可以更进一步理解 `move` 这个概念。

[^fn:1]: 这点可以通过生成 Rust 源码的 LLVM IR 来验证（命令： `cargo rustc --
    --emit=llvm-ir` ），例如这个[案例](https://stackoverflow.com/a/30290070/1066512)。
